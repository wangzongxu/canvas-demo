<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <style type="text/css">
    *{
      margin: 0;
      padding: 0;
    }
    html,body{
      width: 100%;
      height: 100%;
      overflow: hidden;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
</body>
<script src="./model.js" charset="utf-8"></script>
<script type="text/javascript">
  var screen = document.body.getBoundingClientRect();
  var HEIGHT = screen.height;
  var WIDTH = screen.width;
  var MARGINTOP = 1;  // 上边距
  var MARGINLEFT = 1;  // 左边距
  var SPACE = 32;
  var ENTER = 13;
  var UP = 38;
  var LEFT = 37;
  var RIGHT = 39;
  var DOWN = 40;
  var curModel = window.brickModel[0];

  // 砖块宽高 & 颜色
  var bW = (WIDTH - (curModel[0].length) * 2) / curModel[0].length ; // 减去每一个左右间距为1
  var bH = (HEIGHT - (curModel.length) * 2) / 2 / curModel.length ; // 宽高成等比例
  var bColors = 'rgb(153,209,210)';
  var bricks = []; // 所有砖块

  // 木头宽高 & 初始坐标 & 颜色
  var w = {
    w: WIDTH / 5,
    h: bH / 2,
    x: WIDTH / 2 - WIDTH / 5 /2,
    y: HEIGHT - bH / 2,
    colors: 'rgb(243,179,108)'
  }

  // 球半径 & 初始圆心坐标 & 颜色 & 运动数据
  var c = {
    r: bH / 4,
    x: w.x + w.w / 2,
    y: w.y - bH / 4,
    colors: 'rgb(229,71,70)',
    xs: 2, // x 速度
    ys: 2, // y 速度
  }

  var canvas = document.getElementById('canvas');
  var cxt = canvas.getContext('2d');
  canvas.height = HEIGHT;
  canvas.width = WIDTH;

  // API兼容
  window.animationFrame = (function(){
    return  window.requestAnimationFrame       ||
            window.webkitRequestAnimationFrame ||
            window.mozRequestAnimationFrame    ||
            window.msRequestAnimationFrame    ||
            window.oRequestAnimationFrame    ||
            function( callback ){
              window.setTimeout(callback, 1000 / 60);
            };
  })();

  // 初始化
  function init(cxt){
    clearAll(cxt);
    initBrick(cxt, curModel);
    drawBrick(cxt, bricks);
    drawWood(cxt, w);
    drawGlobe(cxt, c);
  }

  // 动画开始
  function go(cxt){
    animationFrame(function(){
      clearAll(cxt);
      drawBrick(cxt, bricks);

      runingWood(cxt, w);
      runingGlobe(cxt, c);
      if(bricks.length===0){
        alert('胜利');
        window.location.reload();
      }
      if(window.canGo){
        go(cxt);
      }
    })
  }

  // 清空
  function clearAll(cxt){
    cxt.clearRect(0, 0, cxt.canvas.width, cxt.canvas.height);
  }

  function drawBrick(cxt,bricks){
    for (var i = 0; i < bricks.length; i++) {
      var brick = bricks[i];
      rect(cxt, brick.x + MARGINLEFT, brick.y + MARGINTOP, brick.w, brick.h, brick.color);
    }
  }
  // 初始化砖块数量和坐标
  function initBrick(cxt, model){
    if(bricks.length > 0)return; // 只添加一次
    var y = 0;
    var x = 0;
    for(var i = 0; i < model.length; i ++){
      var row = model[i];
      for(var j = 0; j < row.length; j ++){
        var brick = row[j];
        if(brick){
          bricks.push({
            x: x + MARGINLEFT,
            y: y + MARGINTOP,
            w: bW,
            h: bH,
            color: bColors
          });
        }
        x += bW + 2;
      }
      x = 0;
      y += bH + 2; // 方块上下间隔一像素
    }
    y = 0;
  }

  // 绘制木板
  function drawWood(cxt, w){
    rect(cxt, w.x, w.y, w.w, w.h, w.colors);
  }
  function runingWood(cxt, w){
    drawWood(cxt, w);
  }
  // 绘制球
  function drawGlobe(cxt, c){
    circle(cxt, c.x, c.y, c.r, c.colors);
  }
  function runingGlobe(cxt,c){
    c.x -= c.xs;
    c.y -= c.ys;

    collisionOf(c,w);
    collisionWall(c);

    for(var i = 0; i < bricks.length; i++){
      var brick = bricks[i];
      var isCollisioned = false;
      collisionOf(c, brick, function(){
        isCollisioned = true;
        bricks.splice(i, 1);
      });
      if(isCollisioned){
        break;
      }
    }
    drawGlobe(cxt, c);
  }

  // 处理碰撞木板
  function collisionOf(c, w, cb){
    var r = c.r;
    if(c.x + r > w.x && c.x - r < w.x + w.w && c.y + r > w.y && c.y - r < w.y + w.h){ // 碰撞到了
      var top = c.y + r - w.y; //与木头顶边距离
      var left = c.x + r - w.x; //与木头左边距离
      var right = w.x + w.w - c.x - r; //与木头右边距离
      var bottom = w.y + w.h - c.y - r; // 与木头底边距离
      var min = Math.min(bottom,left,right,top);
      if(min === top){ // 底边
        c.ys = -c.ys;
        c.y = w.y - r;
      }else if(min === bottom){ // 底
        c.ys = -c.ys;
        c.y = w.y + w.h + r;
      }else if(min === left){ // 左
        c.xs = -c.xs;
        c.x = w.x - r;
      }else if(min === right){ // 右
        c.xs = -c.xs;
        c.x = w.x + w.w + r;
      }
      cb && cb();
    }
  }

  // 处理碰撞墙壁
  function collisionWall(c){
    var r = c.r;
    if( c.y - r < 0){
      c.ys = -c.ys;
      c.y = 0 + r;
    }else if(c.y + r > HEIGHT){
      c.ys = -c.ys;
      c.y = HEIGHT - r;
      over();
    }
    if(c.x - r < 0){
      c.xs = -c.xs;
      c.x = 0 + r;
    }else if(c.x + r > WIDTH){
      c.xs = -c.xs;
      c.x = WIDTH - r;
    }
  }

  // 绘制矩形
  function rect(cxt, x1, y1, x2, y2, color){
    cxt.beginPath();
    cxt.rect(x1, y1, x2, y2);
    cxt.fillStyle = color || 'black';
    cxt.fill()
  }

  // 绘制圈
  function circle(cxt, x, y, r, color) {
      cxt.beginPath();
      cxt.arc(x, y, r, 0, 2 * Math.PI, false);
      cxt.fillStyle = color;
      cxt.fill();
  }

  // 结束
  function over(){
    alert('游戏结束');
    window.location.reload();
  }

  // 事件绑定
  function bindEvent(cxt) {

    // 开始
    on(UP, goUp);
    function goUp(){
      if(window.canGo)return;
      window.canGo=true;
      go(cxt);
    }

    // 停止
    on(DOWN, function(){
      window.canGo=false;
    });

    // 左移动
    on(LEFT, goLeft);
    function goLeft(){
      if(w.x <= 0)return;
      w.x-=30;
      if(!window.canGo){
        c.x-=30;
        init(cxt);
      };
    }
    // 右移动
    on(RIGHT, goRight);
    function goRight(){
      if(w.x + w.w >= WIDTH)return;
      w.x+=30;
      if(!window.canGo){
        c.x+=30;
        init(cxt);
      };
    }
    // 移动端
    canvas.addEventListener('touchend',function(e){
      var x = e.changedTouches[0].pageX;
      var y = e.changedTouches[0].pageY;
      if(y > HEIGHT / 2){ // 下半屏幕
        if(x > WIDTH / 2){ // 左右移动
          goRight();
        }else{
          goLeft();
        }
      }else{
        goUp();
      }
    })

    // 键盘按下
    function on(keyCode,cb){
      document.body.addEventListener('keydown', function(e){
        e.preventDefault();
        if(e.keyCode === keyCode){
          cb();
        }
      })
    }
  }

  document.addEventListener('DOMContentLoaded', function(){
    init(cxt);
    bindEvent(cxt);
  })
</script>
</html>
