<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>hitBricks</title>
  <style type="text/css">
    *{
      margin: 0;
      padding: 0;
    }
    html,body{
      width: 100%;
      height: 100%;
      overflow: hidden;
    }
    .msg{
      width: 100%;
      height: 100px;
      position: fixed;
      left: 0;
      right: 0;
      top: 0;
      bottom: 0;
      margin: auto;
      font-size: xx-large;
      text-align: center;
      color: #607D8B
    }
    .again{
      width: 100%;
      height: 50px;
      line-height: 50px;
      position: fixed;
      left: 0;
      right: 0;
      bottom: 20%;
      margin: auto;
      font-size: xx-large;
      text-align: center;
      color: #607D8B;
      background: rgba(153, 209, 210, 0.38)
    }
    .hide{
      display: none
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <p class="msg hide"></p>
  <p class="again hide">再次挑战</p>
</body>
<script src="./model.js" charset="utf-8"></script>
<script type="text/javascript">
  var screen = document.body.getBoundingClientRect();
  var MSG = document.querySelector('.msg');
  var AGAIN = document.querySelector('.again');
  var HEIGHT = screen.height;
  var WIDTH = screen.width;
  var MARGINTOP = 1;  // 上边距
  var MARGINLEFT = 1;  // 左边距
  var SPACE = 32;
  var ENTER = 13;
  var UP = 38;
  var LEFT = 37;
  var RIGHT = 39;
  var DOWN = 40;
  var SUM = 0; // 打掉砖块数
  var INDEX = 0; // 砖块模板
  var curModel = window.brickModel[INDEX];

  // 砖块宽高 & 颜色
  var bW = (WIDTH - (curModel[0].length) * 2) / curModel[0].length ; // 减去每一个左右间距为1
  var bH = (HEIGHT - (curModel.length) * 2) / 2 / curModel.length ; // 宽高成等比例
  var bricks = []; // 所有砖块
  var bricksColors = {
    1: 'rgb(153,209,210)',// 正常砖块 标识 1
    2: 'rgba(255, 53, 85, 0.88)', // 加速砖块 标识 2
    3: 'rgba(28, 179, 26, 0.41)', // 减速砖块 标识 3
    4: 'rgba(0, 153, 235, 0.55)', // 加长模板 标识 4
    5: 'rgba(170, 172, 184, 0.72)', // 缩短模板 标识 5
  }

  // 木头宽高 & 初始坐标 & 颜色
  var w = {
    w: WIDTH / 5,
    h: bH / 2,
    x: WIDTH / 2 - WIDTH / 5 /2,
    y: HEIGHT - bH / 2,
    colors: 'rgb(243,179,108)'
  }

  // 球半径 & 初始圆心坐标 & 颜色 & 运动数据
  var c = {
    r: bH / 4,
    x: w.x + w.w / 2,
    y: w.y - bH / 4,
    colors: 'rgb(229,71,70)',
    xs: 2, // x 速度
    ys: 2, // y 速度
  }

  var canvas = document.getElementById('canvas');
  var cxt = canvas.getContext('2d');
  canvas.height = HEIGHT;
  canvas.width = WIDTH;

  // API兼容
  window.animationFrame = (function(){
    return  window.requestAnimationFrame       ||
            window.webkitRequestAnimationFrame ||
            window.mozRequestAnimationFrame    ||
            window.msRequestAnimationFrame    ||
            window.oRequestAnimationFrame    ||
            function( callback ){
              window.setTimeout(callback, 1000 / 60);
            };
  })();

  // 初始化
  function init(cxt){
    clearAll(cxt);
    initBrick(cxt, curModel);
    drawBrick(cxt, bricks);
    drawWood(cxt, w);
    drawGlobe(cxt, c);
  }

  // 动画开始
  function go(cxt){
    animationFrame(function(){
      clearAll(cxt);
      drawBrick(cxt, bricks);

      runingWood(cxt, w);
      runingGlobe(cxt, c);
      if(bricks.length===0){
        nextModel();
      }
      if(window.canGo){
        go(cxt);
      }
    })
  }

  // 下一关
  function nextModel(){
    window.canGo = false;
    curModel = window.brickModel[++ INDEX];
    if(!curModel){ // 没有模板了从第一个开始
      INDEX = 0;
      curModel = window.brickModel[INDEX];
    }
    // 初始化木块位置
    w.w = WIDTH / 5;
    w.h = bH / 2;
    w.x = WIDTH / 2 - WIDTH / 5 /2;
    w.y = HEIGHT - bH / 2;
    // 初始化球位置
    c.x = w.x + w.w / 2;
    c.y = w.y - bH / 4;
    init(cxt);
  }

  // 清空
  function clearAll(cxt){
    cxt.clearRect(0, 0, cxt.canvas.width, cxt.canvas.height);
  }

  // 砖块绘制
  function drawBrick(cxt,bricks){
    for (var i = 0; i < bricks.length; i++) {
      var brick = bricks[i];
      rect(cxt, brick.x + MARGINLEFT, brick.y + MARGINTOP, brick.w, brick.h, brick.color);
    }
  }

  // 初始化砖块数量和坐标
  function initBrick(cxt, model){
    if(bricks.length > 0)return; // 只添加一次
    var y = 0;
    var x = 0;
    for(var i = 0; i < model.length; i ++){
      var row = model[i];
      for(var j = 0; j < row.length; j ++){
        var brick = row[j];
        if(brick){
          bricks.push({
            x: x + MARGINLEFT,
            y: y + MARGINTOP,
            w: bW,
            h: bH,
            color: bricksColors[brick]
          });
        }
        x += bW + 2;
      }
      x = 0;
      y += bH + 2; // 方块上下间隔一像素
    }
    y = 0;
  }

  // 绘制木板
  function drawWood(cxt, w){
    rect(cxt, w.x, w.y, w.w, w.h, w.colors);
  }

  // 绘制球
  function drawGlobe(cxt, c){
    circle(cxt, c.x, c.y, c.r, c.colors);
  }

  // 木头运动处理
  function runingWood(cxt, w){
    drawWood(cxt, w);
  }

  // 球的运动处理
  function runingGlobe(cxt,c){
    c.x -= c.xs;
    c.y -= c.ys;

    collisionOf(c,w);
    collisionWall(c);

    for(var i = 0; i < bricks.length; i++){
      var brick = bricks[i];
      var isCollisioned = false;
      collisionOf(c, brick, function(){
        isCollisioned = true;
        SUM += 1;
        brickEffect(brick.color);
        bricks.splice(i, 1);
      });
      if(isCollisioned){
        break;
      }
    }
    drawGlobe(cxt, c);
  }

  // TODO:提示信息css3
  function flyAlert(cxt,msg){
    cxt.beginPath();
    cxt.strokeStyle = 'red';
    cxt.font = 'large Airal';
    cxt.textAlign = 'right';
    cxt.fillText(msg,WIDTH/2,HEIGHT/2);
  }

  // 处理砖块种类效果
  function brickEffect(color){
    switch (color) {
      case bricksColors[2]:
        speed(c);
        break;
      case bricksColors[3]:
        lazy(c);
        break;
      case bricksColors[4]:
        long(w);
        break;
      case bricksColors[5]:
        short(w);
        break;
    }

    // 加速2倍
    function speed(c){
      c.xs *= 2;
      c.ys *= 2;
      setTimeout(function(){
        c.xs /= 2;
        c.ys /= 2;
      },7000)
    }

    // 减速2倍
    function lazy(c){
      c.xs /= 2;
      c.ys /= 2;
      setTimeout(function(){
        c.xs *= 2;
        c.ys *= 2;
      },7000)
    }

    // 加长模板1.5倍
    function long(w){
      var l = w.w * 1.5;
      var pre = l - w.w;
      w.w = l;
      w.x -= pre / 2;
      setTimeout(function(){
        var l = w.w / 1.5;
        var pre = w.w - l;
        w.w = l;
        w.x += pre / 2;
      },7000)
    }

    // 缩短模板
    function short(w){
      var l = w.w / 1.5;
      var pre = w.w - l;
      w.w = l;
      w.x += pre / 2;
      setTimeout(function(){
        var l = w.w * 1.5;
        var pre = l - w.w;
        w.w = l;
        w.x -= pre / 2;
      },7000)
    }
  }

  // 处理碰撞除墙壁外的物体
  function collisionOf(c, w, cb){
    var r = c.r;
    if(c.x + r > w.x && c.x - r < w.x + w.w && c.y + r > w.y && c.y - r < w.y + w.h){ // 碰撞到了
      var top = c.y + r - w.y; //与木头顶边距离
      var left = c.x + r - w.x; //与木头左边距离
      var right = w.x + w.w - c.x + r; //与木头右边距离
      var bottom = w.y + w.h - c.y + r; // 与木头底边距离
      var min = Math.min(bottom,left,right,top);
      console.log({
        top:top,
        bottom:bottom,
        left:left,
        right:right
      })
      if(min === top){ // 底边
        c.ys = -c.ys;
        c.y = w.y - r;
      }else if(min === bottom){ // 底
        c.ys = -c.ys;
        c.y = w.y + w.h + r;
      }else if(min === left){ // 左
        c.xs = -c.xs;
        c.x = w.x - r;
      }else if(min === right){ // 右
        c.xs = -c.xs;
        c.x = w.x + w.w + r;
      }
      cb && cb();
    }
  }

  // 处理碰撞墙壁
  function collisionWall(c){
    var r = c.r;
    if( c.y - r < 0){
      c.ys = -c.ys;
      c.y = 0 + r;
    }else if(c.y + r > HEIGHT){
      c.ys = -c.ys;
      c.y = HEIGHT - r;
      over();
    }
    if(c.x - r < 0){
      c.xs = -c.xs;
      c.x = 0 + r;
    }else if(c.x + r > WIDTH){
      c.xs = -c.xs;
      c.x = WIDTH - r;
    }
  }

  // 绘制矩形
  function rect(cxt, x1, y1, x2, y2, color){
    cxt.beginPath();
    cxt.rect(x1, y1, x2, y2);
    cxt.fillStyle = color || 'black';
    cxt.fill()
  }

  // 绘制圈
  function circle(cxt, x, y, r, color) {
      cxt.beginPath();
      cxt.arc(x, y, r, 0, 2 * Math.PI, false);
      cxt.fillStyle = color;
      cxt.fill();
  }

  // 结束
  function over(){
    window.canGo = false;
    cancelEvent();
    var str = '';
    if(SUM<25){
      str = '我仅仅打掉了' + SUM + '个砖块，加加油！';
    }else if(SUM<50){
      str = '我仅打掉了' + SUM + '个砖块，加油！';
    }else if(SUM<75){
      str = '我打掉了' + SUM + '个砖块，快可以做点什么了';
    }else if(SUM<100){
      str = '我打掉了' + SUM + '个砖块，可以为汪星人盖一个家';
    }else if(SUM<125){
      str = '我打掉了' + SUM + '个砖块，可以盖一个洗手间';
    }else if(SUM<150){
      str = '我打掉了' + SUM + '个砖块，可以盖一个单人间';
    }else if(SUM<175){
      str = '我打掉了' + SUM + '个砖块，可以盖一个双人间';
    }else if(SUM<200){
      str = '我打掉了' + SUM + '个砖块，可以盖一个三人间';
    }else if(SUM>=225){
      str = '我打掉了' + SUM + '个砖块，可以盖一个温暖的家';
    }
    document.title = str;
    MSG.innerHTML = str;
    MSG.classList.remove('hide');
    AGAIN.classList.remove('hide');
  }

  // 事件列表
  var eventMap = {
    goUp:function (e){
      if(e.keyCode === UP || e === 'touch'){
        if(window.canGo)return;
        window.canGo=true;
        go(cxt);
      }
    },
    goLeft:function (e){
      if(e.keyCode === LEFT || e === 'touch'){
        if(w.x <= 0)return;
        w.x -= w.w * 0.4;
        if(!window.canGo){
          c.x -= w.w * 0.4;
          init(cxt);
        };
      }
    },
    goRight:function (e){
      if(e.keyCode === RIGHT || e === 'touch'){
        if(w.x + w.w >= WIDTH)return;
        w.x += w.w * 0.4;
        if(!window.canGo){
          c.x += w.w * 0.4;
          init(cxt);
        };
      }
    },
    stop:function(e){
      if(e.keyCode === DOWN){
        window.canGo=false;
      }
    },
    touch:function(e){
      var x = e.changedTouches[0].pageX;
      var y = e.changedTouches[0].pageY;
      if(y > HEIGHT / 2){ // 下半屏幕
        if(x > WIDTH / 2){ // 左右移动
          eventMap.goRight('touch');
        }else{
          eventMap.goLeft('touch');
        }
      }else{
        eventMap.goUp('touch');
      }
    }
  }
  // 事件绑定
  function bindEvent(cxt) {
    // 移动端
    canvas.addEventListener('touchend', eventMap.touch);
    // 键盘按下
    ['goUp', 'stop', 'goLeft', 'goRight'].forEach(function(item){
      document.body.addEventListener('keydown', eventMap[item]);
    });
    // 再来一次
    AGAIN.addEventListener('click',function(){
      window.location.reload();
    })
  }

  // 取消事件监听
  function cancelEvent(){
    // 移动端
    canvas.removeEventListener('touchend', eventMap.touch);
    // 键盘按下
    ['goUp', 'stop', 'goLeft', 'goRight'].forEach(function(item){
      document.body.removeEventListener('keydown', eventMap[item]);
    });
  }

  window.addEventListener('load', function(){
    init(cxt);
    bindEvent(cxt);
  })
</script>
</html>
